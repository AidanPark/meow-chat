# LLM 오케스트레이션/서빙 프레임워크 선택 가이드 (meow-chat)

> **목적**: meow-chat의 현재 구조(Provider + Orchestration + Streamlit UX)를 기준으로,
> LLM 오케스트레이션/서빙 프레임워크를 *언제/왜/무엇을* 도입할지 의사결정하기 위한 문서입니다.
>
> **원칙**:
> - `docs/plan.md`에는 **순수 실행 계획/체크리스트**만 남깁니다.
> - 기술 선택 근거(왜 지금/나중인지)는 **이 문서**에 기록합니다.
> - 학습 목적 PoC는 가능하지만, **핵심 플로우(문서→OCR→구조화→상담)와 분리**합니다.

---

## 0) 이 문서의 관점 업데이트: "OCR 분석"이 아니라 "고양이 생애주기 플랫폼"

meow-chat에서 OCR 기반 건강검진 분석은 중요한 기능이지만 **전체 서비스의 일부**입니다.
형님이 궁극적으로 만들고자 하는 것은:

- 고양이의 생애주기 전반을 커버하는 **장기 컨텍스트 관리 플랫폼**
  - 추억(사진/텍스트/음성)
  - 건강(검진/증상/투약/병원 기록)
  - 쇼핑(사료/모래/용품 구매, 추천)
  - 입양 시 기록의 단절 없는 관리(서류/기록/변경 이력)

따라서 프레임워크 도입 여부도 "검사결과 분석 단일 워크플로우" 관점이 아니라,
**장기 기억(저장/조회/권한/요약) + 멀티모달 + 개인화** 관점에서 판단해야 합니다.

---

## 1) (재정의) 이 서비스에서 프레임워크가 진짜로 의미 있는 축 4가지

### 1.1 장기 컨텍스트(메모리) 파이프라인
장기 메모리는 "그냥 DB에 저장"로 끝나지 않고 아래 흐름을 갖습니다.

- 수집: 텍스트/이미지/음성/문서/구매 이력
- 정규화: 엔티티(고양이/보호자/병원/상품) + 타임라인(날짜)
- 요약: 최근 N일 요약, 주제별 요약(건강/쇼핑/추억)
- 검색: 키워드/임베딩 기반 검색
- 컨텍스트 구성: 질문 의도에 맞춰 필요한 기억만 추출(토큰 예산 관리)

이 파이프라인이 커질수록 프레임워크(특히 RAG/워크플로우/서빙 분리)의 가치가 커집니다.

### 1.2 멀티모달(사진/음성) 처리 워크플로우
- 사진: 앨범 분류, 이벤트(생일/입양일/병원 방문) 자동 태깅
- 음성: 통화/메모 전사(STT) → 요약/태깅
- 문서: PDF/이미지 OCR → 구조화

멀티모달 입력이 늘어나면:
- 비동기 처리(큐/워커)
- 재시도/부분 실패 처리
- 비용/지연 관측
이 빠르게 필요해집니다.

### 1.3 개인화/권한/데이터 경계(멀티 고양이/가족 공유)
장기 플랫폼이 되면 단일 사용자 세션을 넘어:
- 여러 고양이 프로필
- 가족/공동 보호자 공유
- 민감 정보 접근 제어
- 데이터 삭제/내보내기

같은 "상태/권한"이 핵심 문제가 됩니다.
이건 오케스트레이션 프레임워크라기보다 **서빙/API/DB 설계** 쪽의 필요성이 커집니다.

### 1.4 신뢰/근거(health) + 추천(쇼핑) + 회상(추억)
도메인이 3개로 확장되면:
- 건강: 안전장치/근거/불확실성
- 쇼핑: 추천 근거/가격/재고/선호
- 추억: 감성 톤/프라이버시

각 도메인별 정책/프롬프트/툴이 분화되고,
그걸 "한 번의 프롬프트"로 해결하려 하면 복잡도가 폭발합니다.
→ 결국 **도메인별 파이프라인/툴/메모리 전략**이 필요해집니다.

---

## 2) 지금 구조(2026-01)가 장기 플랫폼으로 확장 가능한 이유

현재 구조는 OCR 기능 하나만이 아니라, 장기 플랫폼으로 확장하기 좋은 형태를 이미 갖고 있습니다.

- UI(`app/`) ↔ 로직(`src/`) 분리
- Provider 패턴(OCR/LLM)로 외부 의존성 격리
- Orchestration 레이어(IntentClassifier/Router/Responder)로 기능 분기 기반 탑재 가능
- 도메인 계층으로 "결정론" 로직(validator/assessment)을 분리해서 테스트 가능

즉, 지금 당장 LangGraph 같은 프레임워크를 넣지 않아도,
**플랫폼의 뼈대(레이어/책임 분리)는 이미 마련**되어 있습니다.

---

## 3) (게이트 재정의) 프레임워크 도입 판단은 "기능 확대"가 아니라 "운영 요구"가 트리거

OCR 분석이 잘 된다고 프레임워크가 필요해지는 게 아니라,
아래 운영/제품 신호가 오면 도입이 이득입니다.

### 3.1 API/서빙 분리(FastAPI 등)가 유리해지는 신호
- 멀티모달 처리(특히 OCR/STT)가 늘어 Streamlit 단일 프로세스가 버거움
- 비동기 처리/작업 큐가 필요
- 사용자 인증/권한/공유(가족 계정)가 들어감
- 모바일 앱/외부 클라이언트를 붙일 계획

### 3.2 워크플로우 프레임워크(LangGraph)가 유리해지는 신호
- "한 번 호출"이 아니라 단계형 UX가 많아짐
  - 예: 업로드→품질평가→재시도→저장→요약→상담
- 실패/부분 실패 처리(재시도/대체 경로)가 많아짐
- 장기 메모리 컨텍스트 구성(검색→요약→선별→응답)이 고정 파이프라인이 됨

### 3.3 RAG 프레임워크(LlamaIndex/LangChain-RAG)가 유리해지는 신호
- 건강/쇼핑/입양 문서 등 "내부 문서"가 늘고 출처 제시가 필수
- 사용자 데이터(개인화) + 외부 지식(근거)을 함께 검색해야 함

---

## 4) 로드맵(업데이트): "한 기능"이 아니라 "메모리 플랫폼" 중심의 단계적 도입

### Step 0 (현재) 프레임워크 없이 MVP 안정화
- Router/Responder 유지
- 문서(OCR) 분석은 deterministic + LLM 설명 전담

### Step 1 (가장 먼저 필요한 플랫폼화) "저장" 레이어 도입
- 사용자/고양이 프로필(엔티티)
- 타임라인(이벤트)
- 첨부(사진/음성/문서) 메타

> 이 단계는 LangGraph보다 **DB/API 설계**가 먼저입니다.

### Step 2 (서빙 분리) FastAPI + Auth + 작업 큐(선택)
- 외부 클라이언트(모바일) 대비
- OCR/STT 비동기 처리
- 관측(로그/비용/latency)

### Step 3 (메모리 검색) 임베딩/검색 + 요약(개인화 컨텍스트)
- "최근 30일 요약" 같은 고정 기능부터
- 이후 질문 의도 기반 컨텍스트 구성으로 확장

### Step 4 (필요 시) LangGraph / RAG 도입
- LangGraph: 컨텍스트 구성/품질 평가/재시도 같은 상태 머신이 복잡해질 때
- RAG: 건강/쇼핑의 근거/출처가 필수일 때

---

## 5) Step 6 체크리스트 보강: "이 서비스는 워크플로우가 중요한가?"

**지금 당장**은 Router/Responder + 코드 기반 품질 게이트로 충분할 가능성이 큽니다.
하지만 **장기 컨텍스트 플랫폼**으로 진화하면 워크플로우 중요도는 올라갑니다.

LangGraph(또는 유사 상태 머신) 도입을 고려할 신호(2개 이상이면 강력 고려):
- OCR/STT/프로필/쇼핑 등 입력이 늘어나고, 실패/부분 실패 처리가 반복된다
- "저장" 이후에 반드시 수행해야 하는 작업이 많다(요약/태깅/인덱싱)
- 질문 시 컨텍스트 구성(검색→요약→선별)을 매번 수행한다
- 비용/지연 때문에 LLM 호출을 단계적으로 쪼개고 캐싱해야 한다

---
