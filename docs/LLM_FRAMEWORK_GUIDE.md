# LLM 오케스트레이션/서빙 프레임워크 선택 가이드 (meow-chat)

> **목적**: meow-chat의 현재 구조(Provider + ChatService + Streamlit UX)를 기준으로,
> LLM 오케스트레이션/서빙 프레임워크를 *언제/왜/무엇을* 도입할지 의사결정하기 위한 문서입니다.
>
> **원칙**: `docs/plan.md`에는 순수 계획만 남기고, 기술 선택 근거는 이 문서에 기록합니다.

---

## 1) 지금 우리에게 중요한 결론

- **우선순위 고정**: UX + 핵심 플로우(문서→OCR→구조화→상담)를 먼저 닫습니다.
- **게이트**: 핵심 플로우가 안정화된 뒤에야 서빙/오케스트레이션 프레임워크 도입 여부를 결정합니다.
- **학습 트랙(선택)**: 학습 목적 PoC는 가능하지만, 본선(핵심 플로우)과 분리해서 진행합니다.

# (추가) 학습 목적을 위한 '단계적 도입' 섹션

## 1.1 학습 목적(스몰톡 단계부터)일 때의 결론

형님 목적처럼 **학습/경험**이 중요하다면, "프레임워크 무도입"이 꼭 정답은 아니에요.
다만 아래 원칙을 지키면 학습 효율을 챙기면서도 레포가 망가지지 않습니다.

- 원칙 1) **서빙 프레임워크(HTTP API)와 오케스트레이션 프레임워크(LangChain/LangGraph)를 분리해서 생각**하기
- 원칙 2) 처음에는 **LLM 1회 호출**만 API로 빼서 “관측/에러/타임아웃/리트라이” 같은 운영 기본기를 학습
- 원칙 3) 기존 Provider/ChatService 구조를 유지하고, 프레임워크는 **겉에 래핑**하는 방식으로 점진 도입

---

## 2) 추천: 학습용 최소 도입 → 점진 확장 로드맵

### Step A (가장 단순) FastAPI로 "LLM 스몰톡 API" 만들기

- 목적: Streamlit UI와 별개로 **/chat** 엔드포인트 하나를 만들고, 내부에서 기존 `LlmProvider`를 호출
- 배움 포인트:
  - 요청/응답 스키마(Pydantic)
  - 타임아웃/리트라이/에러 핸들링
  - 간단 로깅/사용량(토큰/모델) 기록

> 이 단계는 LangChain을 안 써도 됩니다. “서빙(Serving)”을 먼저 학습하기 좋아요.

### Step B (LangChain 제한 도입) Prompt/Chain을 외부화

- 목적: 프롬프트 템플릿/출력 파서/툴 호출 같은 구성요소를 LangChain으로 분리해서 관리
- 추천 방식: 전체 오케스트레이션을 LangChain에 넘기기보다,
  - “프롬프트 구성 + (선택) 간단 툴 호출” 정도만 제한 도입

### Step C (RAG) 지식 베이스가 필요해지면 LlamaIndex 또는 LangChain-RAG

- 목적: 수의학 지식(출처 포함)을 인덱싱하고 검색 결과를 답변에 반영
- 선택:
  - 지식베이스/인덱싱 중심 학습 → **LlamaIndex**
  - 체인/툴링 통합 중심 학습 → **LangChain**

### Step D (LangGraph) 워크플로우가 복잡해지면 상태머신화

- 예: "문서 업로드됨?" → OCR 품질체크 → 실패 시 재촬영 유도 → 추출 → 해석 → 안전문구 삽입
- 목적: 분기/루프/후처리를 그래프로 명시해서 디버깅/테스트 가능하게 만들기

### Step E (멀티 에이전트) AutoGen/CrewAI는 실험 트랙으로

- 권장: 프로덕션 핵심 경로가 아니라 **별도 실험 트랙**(feature flag)으로 운영

---

## 3) 의사결정 기준(체크리스트)

### 2.1 지금 필요한 복잡도인가?
- OCR → 구조화 → LLM 1~2회 호출 정도는 **프레임워크 없이도** 충분히 운영/테스트 가능합니다.
- 프레임워크는 복잡도를 “없애는” 도구라기보다, **복잡도가 커졌을 때 관리 가능하게 만드는 도구**입니다.

### 2.2 상태(State)와 멀티스텝 워크플로우가 필요한가?
- 예: OCR 품질 평가 → 재촬영 유도 → 표 추출 실패 시 fallback → 이상치 요약 → 질문 의도 분기 등
- 이런 “분기/루프/재시도/검증”이 늘면 **상태 머신형 프레임워크**(예: LangGraph) 가치가 커집니다.

### 2.3 RAG/인덱싱이 핵심이 되는가?
- Phase 2에서 **수의학 지식베이스 구축 + 출처 제시 + 검색 기반 답변**이 핵심이면 RAG 중심 프레임워크(예: LlamaIndex/LangChain)가 유리합니다.

### 2.4 관측 가능성(Trace/비용/평가)이 필요한가?
- 운영 단계에서 “왜 이런 답을 했는지”, “어디서 비용이 새는지”가 중요해지면
  트레이싱/평가 도구를 고려해야 합니다.

### 2.5 벤더/모델 변경 가능성을 얼마나 열어둘 것인가?
- 현재 meow-chat은 Provider 패턴(OpenAI/Anthropic/Dummy)을 이미 갖고 있어 락인을 줄이는 구조입니다.
- 프레임워크를 중앙 오케스트레이션으로 두면 락인이 증가할 수 있어, **필요한 부분만 점진 도입**을 권장합니다.

# (추가) '어떤 걸 먼저 고르면 좋은지' 1줄 요약

## 3.7 한 줄 추천(형님 프로젝트 + 학습 목적)

- **서빙 프레임워크**는 먼저: **FastAPI** (가장 단순, 범용, Python 생태계 표준)
- **오케스트레이션 프레임워크**는 나중에 붙이기:
  - RAG가 필요해지면 **LlamaIndex 또는 LangChain**
  - 워크플로우가 복잡해지면 **LangGraph**

---

## 4) 후보군 요약 (meow-chat 관점)

### 3.1 LangChain
- 강점: 생태계/통합/예제 풍부, RAG·툴링 빠른 조합
- 주의: 추상화가 많아지면 디버깅/테스트 난이도↑
- 적합 시점: **Phase 2에서 RAG/리트리버/툴 호출을 빠르게 붙일 때**(전체 오케스트레이션을 맡기기보다는 제한 도입)

### 3.2 LangGraph
- 강점: 상태/분기/루프/재시도 같은 “워크플로우”를 1급으로 모델링
- 주의: 단순 챗봇에는 과한 편
- 적합 시점: **문서 분석 UX가 단계형으로 커지고**, 결과 품질 제어/검증이 중요해질 때

### 3.3 LlamaIndex
- 강점: 문서 파싱/인덱싱/RAG 파이프라인이 핵심일 때 강력
- 주의: 오케스트레이션 전체보다는 RAG 영역에 최적화
- 적합 시점: **지식베이스 구축(문서 수집·청킹·인덱싱·출처)**이 Phase 2 핵심일 때

### 3.4 Semantic Kernel
- 강점: 기능(스킬/플러그인) 단위 확장, 엔터프라이즈 지향 설계
- 주의: Python 생태계에서 팀 친숙도/레퍼런스가 LangChain 대비 적을 수 있음
- 적합 시점: 장기적으로 안정성·구조화를 최우선으로 할 때

### 3.5 AutoGen / CrewAI (멀티 에이전트)
- 강점: 역할 분담형 에이전트 실험(PoC)에 빠름
- 주의: 의료/준의료 도메인에서는 통제/재현성/비용 리스크가 커질 수 있음
- 적합 시점: **Phase 3 이후 연구/실험용 PoC**에 제한적으로

### 3.6 Langbase 등(서빙/관리 플랫폼)
- 강점: 빠른 데모/운영 편의
- 주의: 현재 meow-chat은 Streamlit 중심이라 “API 분리”가 확정되기 전엔 선도입 리스크
- 적합 시점: Streamlit ↔ API 분리 확정 후, 워크플로우를 API로 고정해 운영하려는 경우

---

## 5) 결정 기록(ADR) 템플릿

- 결정: (예: Phase 2에서 LlamaIndex 도입)
- 이유: (RAG/출처제시/문서 인덱싱이 핵심)
- 대안: (LangChain, 자체 구현)
- 리스크: (락인, 유지보수, 비용)
- 완화책: (Provider 유지, 점진 도입, 관측 도입)
- 재검토 시점: (예: 사용자 100명/일 또는 문서 처리량 증가 시)

# (추가) 학습 기록을 남기기 좋은 ADR 예시

### ADR 예시
- 결정: Step A에서 FastAPI로 `/chat` 엔드포인트를 먼저 분리
- 이유: UI와 무관하게 서빙 기본기(스키마/에러/로그)를 학습하고, 이후 LangChain/LangGraph를 얹을 발판 마련
- 대안: Streamlit 내부에서만 LLM 호출(프레임워크 무도입)
- 리스크: API/UI 분리로 초기 복잡도 증가
- 완화책: 엔드포인트 1개로 시작, Provider/ChatService 재사용
- 재검토 시점: OCR + 상담이 안정화되고 RAG 요구가 생길 때
